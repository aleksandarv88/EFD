============================================================
EFD: ONSET OF DYNAMICS — STAGE 1
RE-COHERENCE ORDER AND INTERNAL TIME
============================================================

## PREAMBLE

All primitives are imported from **EFD Foundations (Math v2.1)**:

  Ω : substrate set of admissible relations (difference pairs)
  M ⊂ Ω : maximally coherent subgraph (coherence manifold)
  ∂M : boundary (admissible but incompatible extensions)
  L : feedback loop  (finite closed path of coherent relations)
  Mₗ : minimal closure ensuring internal consistency of L

Our goal here is to **formalize dynamics** on this structure:
how coherence violations are locally repaired, how these updates
propagate, and how a *partial ordering* of updates (internal time)
emerges necessarily.

---

## 1.  COHERENCE FUNCTIONAL AND LOCAL VIOLATION SET

Let  
 C : Ω → ℝ be a coherence functional.  
It assigns each relation r ∈ Ω a real value measuring its internal
logical consistency (from EFD Foundations §1.2).

Define local inconsistency (violation) set:
 V = { r ∈ M | C(r) < Cₘₐₓ }.

We assume C admits bounded gradient over any finite neighborhood
(subgraph) of M — standard assumption analogous to continuity
in discrete optimization.

---

## 2.  RE-COHERENCE OPERATOR R

**Definition 1 (Re-Coherence Operator).**  
A re-coherence operator  
 R : M → M  
is a transformation acting on M such that for any finite subset S ⊂ M,

 C(R(S)) ≥ C(S) and equality holds iff S is locally maximal.

That is, R monotonically increases coherence until a local optimum
is reached.  
This property parallels *monotone ascent mappings* in fixed-point
theory (Banach, 1922).

**Lemma 1. (Existence of Local Re-Coherence)**  
Given a finite S ⊂ M and bounded C, there exists a finite number n
such that Rⁿ(S) is locally maximal.  
*(Proof)* By bounded monotone sequence theorem over finite S.

---

## 3.  COHERENCE DEPENDENCY GRAPH G

Construct  
 G = (V,E)  
where V = { Mₗ | L is a loop in M } and E = { (Mₗᵢ → Mₗⱼ) | 
 updates in Mₗᵢ affect the coherence of Mₗⱼ }.

Formally, define a relation ≺ on V:

 Mₗᵢ ≺ Mₗⱼ  ⇔  ∃ rᵢ ∈ Mₗᵢ, rⱼ ∈ Mₗⱼ such that 
 ∂C(rⱼ)/∂rᵢ ≠ 0.

Then E = { (Mₗᵢ,Mₗⱼ) | Mₗᵢ ≺ Mₗⱼ }.  
Hence G encodes dependency of coherence between loop closures.

This is mathematically identical to the *Jacobian adjacency graph*
used in dependency analysis of nonlinear systems.

---

## 4.  STRONGLY CONNECTED COMPONENTS (SCCs)

**Definition 2.**  
A strongly connected component (SCC) of G is a maximal subset S ⊂ V
such that ∀ a,b ∈ S, ∃ a path a ↔ b within S.

SCC decomposition is guaranteed by **Kosaraju’s theorem (1978)**:
for any finite directed graph, SCCs form a partition of V.

**Interpretation.**  
Each SCC represents a set of loop closures that must re-cohere
simultaneously — their internal updates are mutually dependent
and thus synchronous within one *re-coherence block*.

---

## 5.  CONDENSATION GRAPH AND PARTIAL ORDER

Let G′ = SCC(G) be the **condensation graph**, whose nodes are SCCs
and edges represent inter-block dependencies.

**Theorem 1 (Acyclicity of G′).**  
G′ is a Directed Acyclic Graph (DAG).  
*(Proof)* By definition, contracting each SCC collapses all cycles;
no edge can re-enter a contracted node.

Define a relation < on SCCs:

 A < B ⇔ ∃ (u,v) ∈ E with u ∈ A, v ∈ B.

Then < is transitive and irreflexive, thus a **partial order**.

This construction mirrors the *topological sorting* in DAG theory
(Kahn 1962).

---

## 6.  SEQUENTIAL RE-COHERENCE AND TIME PARAMETER τ

Define ordered sequence of updates T = (A₁,A₂,…,A_k) such that
A_i < A_{i+1}.  
At each step i:

 M^(i+1) = R_{A_i}(M^(i)),

where R_{A_i} is the local re-coherence acting on SCC A_i.

**Definition 3 (Internal Time τ).**  
τ = |T| is the number of ordered re-coherence steps executed.

---

## 7.  INVARIANCE OF τ UNDER INTERNAL RELABELLING

Let π : V → V be a bijection preserving adjacency (graph isomorphism).
Then E is mapped to E′ = { (π(a), π(b)) | (a,b) ∈ E }.

Because SCCs are invariant under graph isomorphism, the
condensation graph G′ is also isomorphic to G′′ = SCC(G′).

Hence topological orderings T and T′ have equal length: |T| = |T′|.  
Thus τ is **observer-invariant**.

*(Reference: standard result in graph-isomorphism invariants,
see Harary “Graph Theory” 1969, Thm 9.1.)*

---

## 8.  DISCUSSION — EMERGENCE OF TIME

We have shown:

1. A local re-coherence operator R exists (Lemma 1).
2. Dependencies among loop closures form a directed graph G.
3. Decomposition into SCCs → acyclic condensation G′.
4. Ordered updates over G′ yield a discrete parameter τ.
5. τ is invariant under observer relabeling.

Therefore, *time* is not imposed externally but arises as
an intrinsic ordering of coherence updates.

This parallels:
  – topological time in causal set theory (Bombelli et al 1987), and  
  – asynchronous update semantics in distributed fixed-point systems
    (Knaster–Tarski lattice framework).

---

## 9.  FORMAL STATEMENT OF RESULT

**Theorem 2 (Emergence of Causal Order).**  
Given a finite coherence manifold M and a monotone re-coherence
operator R acting over its loop closures {Mₗ}, there exists a
unique (up to isomorphism) directed acyclic ordering G′ of
re-coherence blocks whose topological depth τ defines an
observer-invariant discrete time parameter.

*(Proof)* Immediate from Lemma 1 and Theorem 1 plus definition of τ.

---

## 10.  COROLLARIES AND NEXT STEP

**Corollary 1.**  
If two SCCs are mutually independent (no path between them),
their updates commute: R_A ∘ R_B = R_B ∘ R_A.

**Corollary 2.**  
If the dependency edges form a locally bounded structure,
τ admits a continuum limit τ → t ∈ ℝ, leading to Stage 2
(Propagation and Speed Limit).

---

## CONCLUSION

Stage 1 rigorously establishes *internal time* as the topological
ordering of re-coherence operations.  
This gives the formal mathematical ground on which propagation,
metric, and energy will be defined in later stages.

============================================================
End of Stage 1 — Re-Coherence Order and Internal Time
============================================================
